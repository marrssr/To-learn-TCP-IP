
## 单播，多播，广播的介绍



### 单播(unicast)


单播是说，对特定的主机进行数据传送。例如给某一个主机发送IP数据包。这时候，数据链路层给出的数据头里面是非常具体的目的地址，对于以太网来说，就是网卡的MAC地址（不是FF-FF-FF-FF-FF-FF这样的地址）。现在的具有路由功能的主机应该可以将单播数据定向转发，而目的主机的网络接口则可以过滤掉和自己MAC地址不一致的数据。


### 广播(unicast)


广播是主机针对某一个网络上的所有主机发送数据包。这个网络可能是网络，可能是子网，还可能是所有的子网。如果是网络，例如A类网址的广播就是 netid.255.255.255，如果是子网，则是netid.netid.subnetid.255；如果是所有的子网（B类IP）则是则是 netid.netid.255.255。广播所用的MAC地址FF-FF-FF-FF-FF-FF。网络内所有的主机都会收到这个广播数据，网卡只要把 MAC地址为FF-FF-FF-FF-FF-FF的数据交给内核就可以了。一般说来ARP，或者路由协议RIP应该是以广播的形式播发的。


### 多播(multicast)


可以说广播是多播的特例，多播就是给一组特定的主机（多播组）发送数据，这样，数据的播发范围会小一些(实际上播发的范围一点也没有变小)，多播的MAC地址是最高字节的低位为一，例 如01-00-00-00-00-00。多播组的地址是D类IP，规定是224.0.0.0-239.255.255.255。

虽然多播比较特殊，但是究其原理，多播的数据还是要通过数据链路层进行MAC地址绑定然后进行发送。所以一个以太网卡在绑定了一个多播IP地址之后，必 定还要绑定一个多播的MAC地址，才能使得其可以像单播那样工作。这个多播的IP和多播MAC地址有一个对应的算法，在书的p133到p134之间。可以看到 这个对应不是一一对应的，主机还是要对多播数据进行过滤。

个人的看法：广播和多播的性质是一样的，路由器会把数据放到局域网里面，然后网卡对这些数据进行过滤，只拿到自己打算要的数据，比如自己感兴趣的多播数据，自己感兴趣的组播数据。当一个主机运行了一个处理某一个多播IP的进程的时候，这个进程会给网卡绑定一个虚拟的多播mac地址，并做出来一个多播ip。这样，网卡就会让带有这个多播mac地址的数据进来，从而实现通信，而那些没有监听这些数据的主机就会把这些数据过滤掉，换句话说，多播，是让主机的内核轻松了，而网卡，对不起，您就累点吧。

一些文章也印证了这种想法，最明显的就是局域网监听的原理、实现与防范。

## 一些验证性实验


这些实验并不是很复杂，我们只是要ping一下一般的ip和一个广播地址。首先我ping一下自己所在的子网的某一台主机:


> Reply from 192.168.11.1: bytes=32 time<1ms TTL=255

> Reply from 192.168.11.1: bytes=32 time<1ms TTL=255

> Reply from 192.168.11.1: bytes=32 time<1ms TTL=255

> Reply from 192.168.11.1: bytes=32 time=1ms TTL=255

可以看到，机器返回的是一台主机的回应结果，进而推测，如果我ping一个广播地址呢？结果如下

> Reply from 192.168.11.9: bytes=32 time=1ms TTL=255

> Reply from 192.168.11.174: bytes=32 time<1ms TTL=64

> Reply from 192.168.11.174: bytes=32 time<1ms TTL=64

> Reply from 192.168.11.174: bytes=32 time<1ms TTL=64

> Reply from 192.168.11.218: bytes=32 time<1ms TTL=64

> Reply from 192.168.11.174: bytes=32 time<1ms TTL=64


可以看到，ping返回了一些随机的ip的结果，这些ip都是与主机在同一子网内的ip。我们可以看到，广播实际上是给处于子网内的所有ip发信。

再来一个多播的例子，但是要实现这个多播并不容易，因为我不知道网络内有多少个多播组，就只好利用几个特殊的多播地址来验证了。

对于多播地址，有几个特殊的多播地址被占用，他们是

224.0.0.1--该子网内所有的系统组。
224.0.0.2--该子网内所有的路由器。
224.0.1.1--网络实现协议NTP专用IP。
224.0.0.9--RIPv2专用IP
所以只要ping这几个IP，就应该能得到一些结果，比如说我ping 224.0.0.2。

> Reply from 192.168.11.1: bytes=32 time<1ms TTL=255
> 
> Reply from 192.168.11.1: bytes=32 time<1ms TTL=255
> 
> Reply from 192.168.11.1: bytes=32 time<1ms TTL=255
> 
> Reply from 192.168.11.1: bytes=32 time<1ms TTL=255
> 
> Reply from 192.168.11.1: bytes=32 time<1ms TTL=255
> 
> Reply from 192.168.11.1: bytes=32 time<1ms TTL=255
> 
> Reply from 192.168.11.1: bytes=32 time<1ms TTL=255

我们可以看到，这回ping只返回了一个ip的回应。而这个就是我的网关的地址，这也验证了224.0.0.2是所有路由器的多播(组播)地址

## IGMP协议

IGMP的作用在于，让其他所有需要知道自己处于哪个多播组的主机和路由器知道自己的状态。一般多播路由器根本不需要知道某一个多播组里面有多少个主机，而只要知道自己的子网内还有没有处于某个多播组的主机就可以了。只要某一个多播组还有一台主机，多播路由器就会把数据传输出去，这样，接受方就会通过网卡过滤功能来得到自己想要的数据。为了知道多播组的信息，多播路由器需要定时的发送IGMP查询，IGMP的格式可以看书，各个多播组里面的主机要根据查询来回复自己的状态。路由器来决定有几个多播组，自己要对某一个多播组发送什么样的数据。

这种查询回应数据报的TTL一般是1，而且就算是出错也不产生ICMP差错（没必要）。